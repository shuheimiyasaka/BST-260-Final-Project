---
title: "Simulating_Correlated_Data"
author: "Carly Broadwell"
date: "11/11/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## BST 260 Final Project
### Purpose: R markdown file demonstrating how to simulate correlated data
### Last Modified by CB 11/11/2018

Suppose we have normal random variable $X$. and another random variable $e$ (representing the error term).
```{r}
x <- rnorm(100,15,5)
e <- rnorm(100)
```

We can find the current correlation matrix for these variables:

```{r}
cmat <- var(cbind(x,e))
cmat
```

Then we can use the _Cholesky Decomposition_ to get independence, in essence, 'remove' this existing correlation.

From Wikipedia:

> The Cholesky decomposition is commonly used in the Monte Carlo method for simulating systems with multiple correlated variables. The correlation matrix is decomposed, to give the lower-triangular L. Applying this to a vector of uncorrelated samples u produces a sample vector Lu with the covariance properties of the system being modeled. 

```{r}
chol.mat <- solve(chol(cmat))
indep.mat <- cbind(x,e) %*% chol.mat
var(indep.mat)
```

The covariance terms are essentially/numerically 0.

Next, create a new correlation structure: 
```{r}
my.corr <- matrix(c(1,0.8,0.8,1),nrow=2,ncol=2)
my.corr
```

Get its Cholesky Decomposition, and then redefine it according to the mean and standard deviation of $X$. 

```{r}
chol.my.corr <- chol(my.corr)
correlated.data <- indep.mat %*% chol.my.corr * sd(x)
```

Verify:

```{r}
cor(correlated.data) #should be equal to our specified correlation
pairs(correlated.data) #shows correlation scatterplots
mean(x) == mean(correlated.data[,1])
sd(x)
apply(correlated.data,2,sd)
all.equal(x,correlated.data[,1])
```

All in one function:

```{r}
create_corr_errors <- function(var1,var2,r){
  indep.mat <- cbind(var1,var2) %*% solve(chol(var(cbind(var1,var2))))
  my.corr <- matrix(c(1,r,r,1),nrow=2,ncol=2)
  correlated.data <- indep.mat %*% chol(my.corr) * sd(var1)
  return(correlated.data)
}
test <- create_corr_errors(x,e,0.6)
cor(test)
```

## Does this change when X is truncated normal?

## Does this change for linear combinations of X? (e.g., adding an error term)

## Does this change for non-linear combinations of X?